#!/usr/bin/env python

"""
Class :py:class:`UtilsConvert`
==============================

Usage::
    import psana.pscalib.geometry.UtilsConvert as uc

@author: Mikhail Dubrovin
2020-09-DD - created for lcls1
2025-08-14 - adopted to lcls2
"""

import sys
#from Detector.UtilsLogging import logging, DICT_NAME_TO_LEVEL, STR_LEVEL_NAMES
from psana.detector.UtilsLogging import logging, DICT_NAME_TO_LEVEL, STR_LEVEL_NAMES
#import logging
logger = logging.getLogger(__name__)
#from PSCalib.GeometryAccess import GeometryAccess
from psana.pscalib.geometry.GeometryAccess import GeometryAccess

import numpy as np
#from Detector.GlobalUtils import info_ndarr
#from PSCalib.GlobalUtils import CFRAME_LAB, CFRAME_PSANA
from psana.pscalib.geometry.UtilsPSF import CFRAME_PSANA, CFRAME_LAB
from psana.detector.NDArrUtils import info_ndarr

SEGNAME_TO_PARS = {\
  'EPIX10KA:V1': (1,4,16),\
  'JUNGFRAU:V1': (1,2,8),\
  'SENS2X1:V1' : (1,8,32),\
  'PNCCD:V1'   : (4,),\
  'MTRX:V2:512:512:75:75' : (4,),\
  'EPIX10KA:V2': (1,4,16),\
}


def header_crystfel():
    return\
    '\n; Geometry constants generated by genuine psana'\
    '\n'\
    '\nclen =  /LCLS/detector_1/EncoderValue'\
    '\nphoton_energy = /LCLS/photon_energy_eV'\
    '\nadu_per_eV = 0.1'\
    '\n'\
    '\ndata = /entry_1/data_1/data'\
    '\n'\
    '\ndim0 = %'\
    '\ndim1 = ss'\
    '\ndim2 = fs'\
    '\n'\
    '\n; mask = /entry_1/data_1/mask'\
    '\n; mask_good = 0x0000'\
    '\n; mask_bad = 0xffff'

"""
# per asic info:

p15a1/fs = -0.000000x +1.000000y
p15a1/ss = -1.000000x +0.000000y
p15a1/res = 10000.000             # resolution 1m / <pixel-size>
p15a1/corner_x = 2.500000
p15a1/corner_y = -628.500000
p15a1/coffset = 1.000000          # z-offset correction
p15a1/min_fs = 192
p15a1/max_fs = 383
p15a1/min_ss = 5280
p15a1/max_ss = 5455
p15a1/no_index = 0                # exclude panels from indexing

p15a1/coffset = -0.186288         # z[m] panel offset
"""

def panel_constants_to_crystfel(seg, n, x, y, z):
    """Formats psana constants to CrystFEL format
       Parameters:
       - seg [SegGeometry] - segment eometry object
       - n [int] - segment number in daq array for detector
       - x, y, z [float] - pixel coordimane arrays (in the detector geometry) for single panel
    """

    arows, acols = seg.asic_rows_cols()
    #ssize = seg.size()
    srows, scols = seg.shape()
    pix_size = seg.pixel_scale_size()
    nasics_in_rows, nasics_in_cols = seg.number_of_asics_in_rows_cols()
    nasicsf = nasics_in_cols

    logger.debug(info_ndarr(x, name='  panel %02d x'%n, first=0, last=3))
    logger.debug(info_ndarr(y, name='  panel %02d y'%n, first=0, last=3))

    txt = '\n'
    for a,(r0,c0) in enumerate(seg.asic0indices()):

        vfs = np.array((\
               x[r0,c0+acols-1] - x[r0,c0],\
               y[r0,c0+acols-1] - y[r0,c0],\
               z[r0,c0+acols-1] - z[r0,c0]))
        vss = np.array((\
               x[r0+arows-1,c0] - x[r0,c0],\
               y[r0+arows-1,c0] - y[r0,c0],\
               z[r0+arows-1,c0] - z[r0,c0]))
        nfs = vfs/np.linalg.norm(vfs)
        nss = vss/np.linalg.norm(vss)

        pref = '\np%da%d'%(n,a)

        txt +='%s/fs = %+.6fx %+.6fy %+.6fz' % (pref, nfs[0], nfs[1], nfs[2])\
            + '%s/ss = %+.6fx %+.6fy %+.6fz' % (pref, nss[0], nss[1], nss[2])\
            + '%s/res = %.3f' % (pref, 1e6/pix_size)\
            + '%s/corner_x = %.6f' % (pref, x[r0,c0]/pix_size)\
            + '%s/corner_y = %.6f' % (pref, y[r0,c0]/pix_size)\
            + '%s/coffset = %.6f' % (pref, z[r0,c0]*1e-6)\
            + '%s/min_fs = %d' % (pref, (a%nasicsf)*acols)\
            + '%s/max_fs = %d' % (pref, (a%nasicsf+1)*acols-1)\
            + '%s/min_ss = %d' % (pref, n*srows + (a//nasicsf)*arows)\
            + '%s/max_ss = %d' % (pref, n*srows + (a//nasicsf+1)*arows - 1)\
            + '%s/no_index = 0' % (pref)\
            + '\n'

    return txt


def info_geo(geo):
    """Returns (str) name and index info of the GeometryObject."""
    return 'segment name: %s index: %d' % (geo.oname, geo.oindex)


def info_seg_geo(seg):
    """Returns (str) info of the SegGeometry object parameters."""
    return 'per ASIC info'\
      + '\n  SegGeometry implementation class: %s' % seg.name()\
      + '\n  asic0ind: %s' % str(seg.asic0indices())\
      + '\n  arows: %d acols: %d' % seg.asic_rows_cols()\
      + '\n  ssize: %d' % seg.size()\
      + '\n  seg.shape(): %s' % str(seg.shape())\
      + '\n  pix_size, um: %f' % seg.pixel_scale_size()\
      + '\n  nasics_in_rows: %d nasics_in_cols: %d' % seg.number_of_asics_in_rows_cols()


def geometry_to_crystfel(fname, ofname, cframe=CFRAME_LAB, zcorr_um=None):

    logger.info('geometry_to_crystfel - converts geometry constants from psana to CrystFEL format')

    geo = GeometryAccess(fname, 0, use_wide_pix_center=False)
    x, y, z = geo.get_pixel_coords(oname=None, oindex=0, do_tilt=True, cframe=cframe)
    logger.info(info_ndarr(x, name='x', first=0, last=10))
    logger.info(info_ndarr(y, name='y', first=0, last=10))

    geo1 = geo.get_seg_geo() # GeometryObject
    seg = geo1.algo # object of the SegmentGeometry subclass
    logger.info('%s\n%s' % (info_geo(geo1), info_seg_geo(seg)))

    segname = geo1.oname
    assert segname in SEGNAME_TO_PARS.keys(),\
      'segment name %s is not found in the list of implemented detectors %s'%(segname, str(SEGNAME_TO_PARS.keys()))
    valid_nsegs = SEGNAME_TO_PARS[segname]

    nsegs = int(x.size/seg.size())
    assert nsegs in valid_nsegs, 'number of %s segments %d should be in %s' % (seg.name(), nsegs, str(valid_nsegs))

    shape = (nsegs,) + seg.shape() # (nsegs, srows, scols)
    logger.info('geo shape %s' % str(shape))

    x.shape = shape
    y.shape = shape
    z.shape = shape

    txt = header_crystfel()
    for n in range(nsegs):
        z_um = z[n,:]
        if zcorr_um is not None: z_um -= zcorr_um
        txt += panel_constants_to_crystfel(seg, n, x[n,:], y[n,:], z_um)

    logger.info('Geometry constants in CrystFEL format:\n\n%s\n...\n' % txt[:1000])

    if ofname is not None:
        f = open(ofname,'w')
        f.write(txt)
        f.close()
        logger.info('geometry constants in CrystFEL format saved in: %s' % ofname)


def convert_geometry_to_crystfel(args):
    zcorr = z_correction_from_data(args)
    if zcorr is not None: zcorr *= args.f_um
    geometry_to_crystfel(args.fname, args.ofname, cframe=args.cframe, zcorr_um=zcorr)


def z_correction_from_data(args):
    dsname, zpvname = args.dsname, args.zpvname
    logger.info('z_correction_from_data for dsname: %s  zpvname: %s  f_um: %s' % (dsname, zpvname, str(args.f_um)))
    if dsname is None: return None

    import psana
    ds = psana.DataSource(dsname)
    epics = ds.env().epicsStore()
    zpvnames = ['CXI:DS1:MMS:06.RBV', 'CXI:DS2:MMS:06.RBV', 'MFX:DET:MMS:04.RBV',
                'XPP:ROB:POS:Z', 'AMO:LMP:MMS:10.RBV']

    #epics methods: 'alias', 'aliases', 'getPV', 'names', 'pvName', 'pvNames', 'status', 'value'
    #print('epics.value("DscCsPad_z"):', epics.value('DscCsPad_z'))  # -424.9936
    #print('epics.value("CXI:DS1:MMS:06.RBV"):', epics.value('CXI:DS1:MMS:06.RBV'))  # -424.9936
    #logger.debug('epics.names(): %s' % str(epics.names()))
    #logger.debug('epics.pvNames(): %s' % str(epics.pvNames()))

    if zpvname is None: # use automatic search for z-correction
        logger.info('known z-correction pv names: %s' % ', '.join(zpvnames) )
        foundpvs = [pvname for pvname in zpvnames if pvname in epics.pvNames()]
        nfoundpvs = len(foundpvs)

        if nfoundpvs == 1:
            zpvname = foundpvs[0]
            zcorr = epics.value(zpvname)
            logger.info('AUTO-FOUND z correction(%s) = %f mm' % (zpvname, zcorr))
            return zcorr
        elif nfoundpvs == 0:
            logger.info('pv names: %s' % str(epics.pvNames()))
            logger.info('aliases: %s' % str(epics.aliases()))
            logger.warning('known z-correction variable is NOT FOUND.\nIf you know the pv name, try to use parameter --zpvname for one of pvs of the list above.')
            return None
        else: # nfoundpvs > 1
            logger.warning('MORE THAN ONE known z-correction variable is found: %s' % ', '.join(foundpvs))
            logger.info('Use parameter --zpvname <pv-name> to specify one of them')
            return None

    if zpvname in epics.names():
        zcorr = epics.value(zpvname)
        logger.info('z correction(%s) = %f mm' % (zpvname, zcorr))
        return zcorr
    else:
        logger.info('pv names: %s' % str(epics.pvNames()))
        logger.info('aliases: %s' % str(epics.aliases()))
        logger.warning('z correction pv name %s is UNKNOWN' % zpvname)
        return None


if __name__ == "__main__":

    scrname = sys.argv[0].rsplit('/')[-1]

    fname_jungfrau_8     = '/reg/g/psdm/detector/data2_test/geometry/geo-jungfrau-8-segment.data'
    fname_epix10ka2m_16  = '/reg/g/psdm/detector/data2_test/geometry/geo-epix10ka2m-16-segment.data'
    fname_epix10ka2m_def = '/reg/g/psdm/detector/data2_test/geometry/geo-epix10ka2m-default.data'
    fname_cspad_cxi      = '/reg/g/psdm/detector/data2_test/geometry/geo-cspad-cxi.data'
    fname_pnccd_amo      = '/reg/g/psdm/detector/data2_test/geometry/geo-pnccd-amo.data'
    d_tname   = '0'
    d_fname   = fname_epix10ka2m_16
    d_ofname  = 'geo-crystfel.txt'
    d_loglev  ='INFO'
    d_cframe  = 1
    usage = '\nE.g.: %s' % scrname\
      + '\n  or: %s -t <test-number: 1,2,3,4,5,...>' % (scrname)\
      + '\n  or: %s -f %s -o geo_crystfel.txt -l DEBUG' % (scrname, d_fname)

    import argparse

    parser = argparse.ArgumentParser(usage=usage)
    parser.add_argument('-t', '--tname',   default=d_tname,   type=str, help='test number: 1/2/3/4/5 = epix10ka/jungfrau/cspad/epix10ka/pnccd, def=%s' % d_tname)
    parser.add_argument('-f', '--fname',   default=d_fname,   type=str, help='input geometry file name, def=%s' % d_fname)
    parser.add_argument('-o', '--ofname',  default=d_ofname,  type=str, help='output file name, def=%s' % d_ofname)
    parser.add_argument('-l', '--loglev',  default=d_loglev,  type=str, help='logging level name, one of %s, def=%s' % (STR_LEVEL_NAMES, d_loglev))
    parser.add_argument('--cframe',        default=d_cframe,  type=int, help='coordinate frame 0/1 : psana/LAB, def=%s' % d_cframe)

    args = parser.parse_args()
    s = 'Arguments:'
    for k,v in vars(args).items(): s += '  %12s : %s' % (k, str(v))

    logging.basicConfig(format='[%(levelname).1s] L%(lineno)04d : %(message)s', datefmt='%Y-%m-%dT%H:%M:%S', level=DICT_NAME_TO_LEVEL[args.loglev])
    logging.debug('Logger is initialized for level %s' % args.loglev)
    logging.info(s)

    tname = args.tname

    if   tname=='0': convert_geometry_to_crystfel(args)
    elif tname=='1': geometry_to_crystfel(fname_epix10ka2m_16,  'geo-epix10ka-crystfel.geom')
    elif tname=='2': geometry_to_crystfel(fname_jungfrau_8,     'geo-jungfrau-crystfel.geom')
    elif tname=='3': geometry_to_crystfel(fname_cspad_cxi,      'geo-cspad-crystfel.geom')
    elif tname=='4': geometry_to_crystfel(fname_epix10ka2m_def, 'geo-epix10ka-crystfel.geom')
    elif tname=='5': geometry_to_crystfel(fname_pnccd_amo,      'geo-pnccd-crystfel.geom')
    else: logger.warning('NON-IMPLEMENTED TEST: %s' % tname)

    sys.exit('END OF %s' % scrname)

# EOF
